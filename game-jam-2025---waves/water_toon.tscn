[gd_scene load_steps=16 format=3 uid="uid://c8q3ea6wesjpm"]

[ext_resource type="Script" uid="uid://6jg2wnsqwbki" path="res://scripts/water.gd" id="1_k7utj"]
[ext_resource type="Script" uid="uid://cfma8e6stqmd2" path="res://scripts/mesh.gd" id="1_nnm43"]
[ext_resource type="Script" uid="uid://bstm164sj8s8b" path="res://cameraController.gd" id="2_0poqx"]
[ext_resource type="ArrayMesh" uid="uid://b8i5xc55nf84m" path="res://assets/ship-small.obj" id="4_0poqx"]
[ext_resource type="PackedScene" uid="uid://bet5mpv4rsivg" path="res://row_wave_spawner.tscn" id="5_as4el"]
[ext_resource type="PackedScene" uid="uid://77tnpgrwcg6r" path="res://wave_bump.tscn" id="6_n74q2"]

[sub_resource type="Shader" id="Shader_aitcd"]
code = "	shader_type spatial;
	render_mode blend_mix, depth_draw_opaque, cull_back, diffuse_lambert, specular_schlick_ggx;

	// Wind Waker style water - NekotoArts
	// https://godotshaders.com/shader/wind-waker-water-no-textures-needed/
	// Adapted from https://www.shadertoy.com/view/3tKBDz
	// After which I added in some fractal Brownian motion
	// as well as vertex displacement

	uniform vec4 WATER_COL =  vec4(0.04, 0.38, 0.88, 1.0);
	uniform vec4 WATER2_COL =  vec4(0.04, 0.35, 0.78, 1.0);
	uniform vec4 FOAM_COL = vec4(0.8125, 0.9609, 0.9648, 1.0);
	uniform float distortion_speed = 2.0;
	uniform vec2 tile = vec2(50.0, 50.0);
	uniform float height = 2.0;
	uniform vec2 wave_size = vec2(2.0, 2.0);
	uniform float wave_speed = 1.5;

	const float M_2PI = 6.283185307;
	const float M_6PI = 18.84955592;

	// ---- Nicole's spawned waves (synced with water.gd) ----
	const int MAX_SPAWNED_WAVES = 32;

	uniform int spawned_wave_count;
	uniform vec2 spawned_wave_centers[MAX_SPAWNED_WAVES];
	uniform float spawned_wave_times[MAX_SPAWNED_WAVES];
	uniform float spawned_wave_radius;
	uniform float spawned_wave_height;
	uniform float spawned_wave_lifetime;
	// -------------------------------------------------------


	float random(vec2 uv) {
	    return fract(sin(dot(uv.xy,
	        vec2(12.9898,78.233))) *
	            43758.5453123);
	}

	float noise(vec2 uv) {
	    vec2 uv_index = floor(uv);
	    vec2 uv_fract = fract(uv);

	    // Four corners in 2D of a tile
	    float a = random(uv_index);
	    float b = random(uv_index + vec2(1.0, 0.0));
	    float c = random(uv_index + vec2(0.0, 1.0));
	    float d = random(uv_index + vec2(1.0, 1.0));

	    vec2 blur = smoothstep(0.0, 1.0, uv_fract);

	    return mix(a, b, blur.x) +
	            (c - a) * blur.y * (1.0 - blur.x) +
	            (d - b) * blur.x * blur.y;
	}

	float fbm(vec2 uv) {
	    int octaves = 6;
	    float amplitude = 0.5;
	    float frequency = 3.0;
	    float value = 0.0;
		
	    for(int i = 0; i < octaves; i++) {
	        value += amplitude * noise(frequency * uv);
	        amplitude *= 0.5;
	        frequency *= 2.0;
	    }
	    return value;
	}

	float circ(vec2 pos, vec2 c, float s)
	{
	    c = abs(pos - c);
	    c = min(c, 1.0 - c);

	    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;
	}

	// Foam pattern for the water constructed out of a series of circles
	float waterlayer(vec2 uv)
	{
	    uv = mod(uv, 1.0); // Clamp to [0..1]
		
	    float ret = 1.0;
	    // ... (unchanged giant list of circ() calls) ...
	    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);
	    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);
	    return max(ret, 0.0);
	}

	// Procedural texture generation for the water
	vec3 water(vec2 uv, vec3 cdir, float iTime)
	{
	    uv *= vec2(0.25);
	    uv += fbm(uv) * 0.2;

	    // Parallax height distortion with two directional waves at
	    // slightly different angles.
	    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset
	    float h = sin(uv.x + iTime); // Height at UV
	    uv += a * h;
	    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);
	    uv += a * h;
	    
	    // Texture distortion
	    float d1 = mod(uv.x + uv.y, M_2PI);
	    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);
	    d1 = iTime * 0.07 + d1;
	    d2 = iTime * 0.5 + d2;
	    vec2 dist = vec2(
	        sin(d1) * 0.15 + sin(d2) * 0.05,
	        cos(d1) * 0.15 + cos(d2) * 0.05
	    );
	    
	    vec3 ret = mix(WATER_COL.rgb, WATER2_COL.rgb, waterlayer(uv + dist.xy));
	    ret = mix(ret, FOAM_COL.rgb, waterlayer(vec2(1.0) - uv - dist.yx));
	    return ret;
	}


	void vertex() {
	    float time = TIME * wave_speed;
	    vec2 uv = UV * wave_size;
	    float d1 = mod(uv.x + uv.y, M_2PI);
	    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);
	    d1 = time * 0.07 + d1;
	    d2 = time * 0.5 + d2;
	    vec2 dist = vec2(
	        sin(d1) * 0.15 + sin(d2) * 0.05,
	        cos(d1) * 0.15 + cos(d2) * 0.05
	    );

	    // base Y wave from shader (matches water.gd's dist_y)
	    float wave_y = dist.y;

	        // ---- add Nicole's spawned wave bumps on top (LOCAL space) ----
	    vec2 local_xz = VERTEX.xz;
	    float extra_spawned = 0.0;

	    for (int i = 0; i < MAX_SPAWNED_WAVES; i++) {
	        if (i >= spawned_wave_count) {
	            break;
	        }

	        float age = TIME - spawned_wave_times[i];
	        if (age < 0.0 || age > spawned_wave_lifetime) {
	            continue;
	        }

	        vec2 center = spawned_wave_centers[i]; // also in local space
	        float d = length(local_xz - center);
	        if (d > spawned_wave_radius) {
	            continue;
	        }

	        float k = 1.0 - d / spawned_wave_radius;
	        k *= k; // smoother falloff

	        float t_norm = age / spawned_wave_lifetime;
	        float pulse = sin(t_norm * 3.14159265); // 0 -> 1 -> 0

	        extra_spawned += k * pulse * spawned_wave_height;
	    }

	    wave_y += extra_spawned;
	    // ------------------------------------------------

	    VERTEX.y += wave_y * height;
	}

	void fragment() {
	    vec2 uv = UV;
	    ALBEDO = vec3(water(uv * tile, vec3(0,1,0), TIME * distortion_speed));
	}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_7b4nq"]
render_priority = 0
shader = SubResource("Shader_aitcd")
shader_parameter/WATER_COL = Vector4(0.04, 0.38, 0.88, 1)
shader_parameter/WATER2_COL = Vector4(0.04, 0.35, 0.78, 1)
shader_parameter/FOAM_COL = Vector4(0.8125, 0.9609, 0.9648, 1)
shader_parameter/distortion_speed = 2.0
shader_parameter/tile = Vector2(30, 30)
shader_parameter/height = 3.0
shader_parameter/wave_size = Vector2(4, 4)
shader_parameter/wave_speed = 4.5
shader_parameter/spawned_wave_count = 0
shader_parameter/spawned_wave_centers = PackedVector2Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
shader_parameter/spawned_wave_times = PackedFloat32Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
shader_parameter/spawned_wave_radius = 0.0
shader_parameter/spawned_wave_height = 0.0
shader_parameter/spawned_wave_lifetime = 0.0

[sub_resource type="PlaneMesh" id="PlaneMesh_nnm43"]
material = SubResource("ShaderMaterial_7b4nq")
size = Vector2(200, 200)
subdivide_width = 20
subdivide_depth = 20

[sub_resource type="FastNoiseLite" id="FastNoiseLite_aitcd"]
noise_type = 3
frequency = 0.0084

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_7b4nq"]
seamless = true
noise = SubResource("FastNoiseLite_aitcd")

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_nnm43"]
sky_top_color = Color(0.306739, 0.627731, 0.942088, 1)
sky_horizon_color = Color(0.606278, 0.875287, 0.994238, 1)
sky_cover = SubResource("NoiseTexture2D_7b4nq")
sky_cover_modulate = Color(0.728822, 0.728822, 0.728822, 1)

[sub_resource type="Sky" id="Sky_nnm43"]
sky_material = SubResource("ProceduralSkyMaterial_nnm43")

[sub_resource type="Environment" id="Environment_0poqx"]
background_mode = 2
sky = SubResource("Sky_nnm43")

[sub_resource type="BoxShape3D" id="BoxShape3D_k7utj"]

[node name="Node3D" type="Node3D"]

[node name="Water" type="MeshInstance3D" parent="."]
mesh = SubResource("PlaneMesh_nnm43")
script = ExtResource("1_k7utj")
spawned_wave_height = 0.25
spawned_wave_lifetime = 2.0

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_0poqx")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, -0.945519, 0.325568, 0, -0.325568, -0.945519, 0, 0, 0)
light_energy = 0.97
shadow_enabled = true

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(-0.985551, 0.0131946, -0.168867, -0.00616113, 0.993509, 0.113587, 0.16927, 0.112986, -0.979072, -7.56196, 16.483, -39.5556)
fov = 37.8492
near = 1.0
far = 10000.0
script = ExtResource("2_0poqx")

[node name="Boat" type="RigidBody3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 7.67972, 0)
script = ExtResource("1_nnm43")
float_force = 1.0

[node name="ShipMesh" type="MeshInstance3D" parent="Boat"]
mesh = ExtResource("4_0poqx")
skeleton = NodePath("../..")

[node name="ProbeContainer" type="Node3D" parent="Boat"]

[node name="Marker3D" type="Marker3D" parent="Boat/ProbeContainer"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0255332, 0.586806, 2.92499)

[node name="Marker3D2" type="Marker3D" parent="Boat/ProbeContainer"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.0510664, 0.361696, -3.58853)

[node name="Marker3D3" type="Marker3D" parent="Boat/ProbeContainer"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.59894, 0.339564, -1.40779)

[node name="Marker3D4" type="Marker3D" parent="Boat/ProbeContainer"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.60595, 0.307002, -1.3609)

[node name="CollisionShape3D" type="CollisionShape3D" parent="Boat"]
shape = SubResource("BoxShape3D_k7utj")

[node name="WaveSpawner" parent="." instance=ExtResource("5_as4el")]
bump_scene = ExtResource("6_n74q2")
boat = NodePath("../Boat")
water = NodePath("../Water")
row_interval = 1.5
start_delay = 1.0

[editable path="WaveSpawner"]
